객체 지향의 특성
1. 캡슐화
  속성과 기능을 한데 묶는 것. -> class를 작성하는 것.
  정보 은닉 - 접근제어자를 사용하여 속성과 기능을 보호.
    속성 : 객체가 가지고 있는 고유한 값 또는 처리할 수 있는 값.(변수)
    기능 : 객체가 담당할 수 있는 역할을 제공하는 코드 묶음.(함수)
        함수는 객체 안에 위치할 때 메소드라고 불린다.
2. 상속
3. 다형성
4. 추상화

상속(Inheritance)
  부모의 형질을 자식이 물려받는 것.
  -> 기존에 작성된 클래스를 재사용하여, 새로운 클래스를 작성하는 것.
  두 클래스는 조상(부모), 자손(자식) 관계를 형성.(계층화)
  - 자손 클래스는 조상 클래스의 모든 멤버를 상속받는다.
    (예외. 생성자와 private 멤버는 제외)
  - 자손의 멤버 개수는 조상보다 적을 수 없음.(예외는 제외)
    : 같거나 많다.
  - 단일 상속만 허용.

  상속 키워드 : extends
    새로 만들 클래스명 뒤에 'extends 부모클래스명'을 작성한다.

    class 새클래스명 extends 기존클래스명 { ... }

모든 클래스는 상속을 통해서 만들어 진다.
모든 클래스의 조상 클래스 : Object 클래스.

객체 지향. 시작점도 객체. -> Object 클래스로부터 모든 것이 시작.

class Parent [extends Object] { }//extends Object 생략.
class Child1 extends Parent { }
class Child2 extends Parent { }
class GrandChild extends Child1 { }

상속의 대상은 메소드도 포함. 멤버 변수는 자료형을 변경할 수 없으며,
그대로 사용. 메소드는 변경하여 사용할 필요가 있음.

상속 받은 클래스에서 부모 클래스의 메소드를 변경할 수 있음.
메소드 재정의(Method Overriding) 오버라이딩.
    용어 혼동 주의 : 메소드 오버로딩(Method Overloading)
                -> 같은 이름의 메소드를 여러개 만드는 작업.

  부모 클래스의 메소드를 자식 클래스에서 재정의. 덮어쓰기.
    같은 이름의 메소드를 자식 클래스에서 작성하면, 부모 클래스의
    메소드는 사용되지 않는다.
    (물론, 부모클래스로 만든 인스턴스에서는 사용됨!)
    상속받은 메소드의 내용을 새 클래스에 맞게 변경하는 것.
    규칙) 메소드의 선언부가 동일해야 한다.

Annotation : 주석
    컴파일 되는 주석. 컴파일러에게 주는 명령어.
    @Override : 이 메소드는 재정의하는 메소드임을 알려주는 주석.

메소드의 구성
    void method1()  -> 선언부
    ------------------------
    {
        .....       -> 정의부(body, 몸통)
    }

Object 클래스(최고 조상 클래스)의 메소드를 재정의 하자.
    toString() 메소드 : 인스턴스를 출력할 때 사용하는 메소드.
        '패키지.클래스명@16진수고유넘버' 형태로 출력.

부모의 메소드를 가져와서 쓰는데, 메소드의 내용 중에 일부만 다르고
대부분은 부모 메소드의 내용을 사용하는 경우, 부모의 코드와
자식의 코드를 구분하기 위한 방법이 필요. -> super 키워드

this와 super
  this
    1) this.멤버 - 멤버변수와 매개(지역)변수를 구분할 때 사용.
                  (무조건)멤버변수 앞에 붙인다.
                  멤버변수와 매개변수가 이름이 다르면 사용하지
                  않아도 됨.
    2) this() - 한 생성자에서 다른 생성자를 호출할 때 사용.

  super : 부모클래스를 지칭하는 대명사.
    1) super.멤버 : 부모클래스와 자식클래스에 같은 이름의 멤버를
                작성한 경우, 그 둘을 구분하기 위해 사용.
    2) super() : 부모클래스의 생성자를 호출할 때 사용.
                자식클래스의 생성자에서만 사용 가능.
                자식클래스 생성자의 맨 첫줄에 작성해야 한다.

상속을 활용하는 방법
- 설계단계에서 부터 상속을 고려하는 것이 좋음.
- 필요한 클래스를 따로 작성한 경우, 각 클래스에 공통적으로
  사용할 수 있는 멤버가 있다면, 그 부분만을 추출하여
  하나의 부모클래스로 작성하는 방법을 활용.(이 후의 활용을 위해)
  부모클래스 : 대략적인 개념적 내용
  자식클래스 : 구체적인 정의

상품정보를 저장하는 객체의 클래스화
1. 식품
    식품명, 단가, 수량, 유통기한, 원산지
2. 전자제품
    제품명, 단가, 수량, 보증기간, 일련번호, 제조사

공통적인 정보
   이름, 단가, 수량, 기한(날짜) -> 이 정보들을 부모 클래스로.

접근제어자 protected
    같은 패키지, 다른 패키지지만 상속을 받은 클래스에서
    접근 가능한 멤버로 지정.

접근제어자 public, protected, default, private.

객체 지향의 특성
1. 캡슐화
2. 상속
3. 다형성 : 같은 이름의 여러 모습이 있다.
4. 추상화

다형성(Polymorphism)
  1) 메소드의 다형성 - 오버로드(같은 이름의 여러 메소드)
  2) 참조변수의 다형성 - 한 클래스의 참조변수로 여러 클래스의
                인스턴스를 저장하는 것.
  참조변수의 다형성은 상속관계에서만 나타남!
  부모클래스의 참조변수로 자식클래스로 만든 인스턴스를 저장할
  수 있다.
  문형) 부모클래스명 참조변수 = new 자식클래스명();

  부모클래스의 이름은 빌릴 수 있지만, 본 내용은 자식이기 때문에
  부모의 참조변수로는 사용에 제한이 있다.(본인 확인 필요)
  부모클래스의 참조변수로는 부모클래스에 정의된 멤버만 사용 가능.
  실제 사용 시에는 다시 원래의 형태로 복원해야 한다.
  부모클래스의 참조변수에 저장하는 것 - up casting
  원래의 인스턴스로 되돌리는 것 - down casting

  클래스는 '사용자(개발자) 정의 자료형'이라고 한다.
  즉 형변환을 할 수 있다.
  객체의 형변환 조건)
  1. 객체의 경우 상속관계에서만 형변환이 가능하다.
  2. 부모클래스의 인스턴스는 자식클래스의 참조변수에 저장할 수
     없다.(down casting은 반드시 up casting한 인스턴스만!)
     부모인스턴스 -> 자식참조변수 (X)
     자식인스턴스 -> 부모참조변수 -> 자식참조변수 (O)